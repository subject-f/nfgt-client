# NFGT: Non-Fungible Git Tokens

This document serves to provide an overview of NFGTs.

# Client

## Getting Started

### From Source

1. Ensure that you have the Go toolchain installed
2. Clone the repo
3. Create a `config.yaml` based on `config.example.yaml`, replacing it with relevant values
4. Run the source `go run main.go`
5. Transact!

# Introduction

## Why?

Modern NFTs are slow, energy-inefficient, and suffer from a poor PR problem. Many of these issues stem from the distributed consensus protocols that are inherent to cryptocurrency, despite many NFT implementations still suffering from centralization issues. For example, an NFT's metadata and referenced content may be hosted on a traditional server, resulting in a single point of failure from an availability standpoint.

Thus, we will introduce NFGTs, a new standard that serves to provide an NFT-like interface without the overhead of maintaining a cryptographically secure blockchain.

## High-Level Overview

At a high level, an NFGT is a JSON record in a single JSON file stored in a git repo. This git repo will be considered the beacon chain that is the synchronization mechanism that nodes will subscribe to and communicate with. The repo acts as a broker for the distributed nodes, which allows nodes to run without exposing themselves to the public internet.

However, because anybody can run a node, the chain must provide a mechanism to validate transactions. Thus, nodes can operate in two modes: (1) as a validator, and (2) as an observer. Node types are differentiated by a mechanism called "proof of identity", which is faciliated by the deploy key they are given as configuration. A node with a read-write deploy key effectively becomes a validator, while a node with a read-only deploy key is an observer. Functionally, a validator and an observer differ only by their ability to write transactions to the chain.

In addition, nodes will provide an HTTP API that can be used to read from and transact on the chain. Some additional security aspects that will be discussed below.

# Technical Details

## JSON Record

Each commit of the chain is a JSON record that has, at a minimum, the following schema:

```json
{
	"transaction_id": "string",
	"transaction_time": "number",
	"asset_id": "string",
	"owner_id": "string",
	"successor_hash": "string",
	"metadata": {
		...
	}
}
```

The `transaction_id` is a UUID generated by the node writing the transaction. This is required in order to provide external clients the ability to check whether their transactions have been written to the chain yet.

The `tranaction_time` is the time at which the node sees the transaction.

The `asset_id` is some string identifier for the given record. For example, it could be an image source URL or a UUID.

The `owner_id` is some string identifier for the owner of the given record. These can be arbitrary identifiers. At a minimum, stable IDs like user IDs should be encoded so that they aren't easily crawled by public search engines, but this is up to the caller to implement.

The `successor_hash` is a hash of the passphrase required to write a successor to the record.

Finally, the `metadata` is all metadata related to the record, and is up to the caller to define. Generally, one should expect an image source and owner information such as name and display picture.

Nodes will expect the last line for a given `asset_id` to be the current record.

## Beacon Chain

The beacon chain is the synchronization mechanism between nodes; it is the centralized broker that coordinates distributed state. This differs from traditional cryptocurrencies that use a gossip protocol to communicate.

The chain itself is a git repo hosted on GitHub that creates a new branch for each interaction chain.

An interaction chain is a node-specific commit chain that refers to a specific resource.

### Interaction Chains

In git terms, an interaction chain is simply a branch.

In order to coordinate and establish well-known metadata to be discovered, there are several reserved keywords that should not be used for branch naming:

- `well-known`
- `common`
- `metadata`

Clients should also be careful about creating local refs that reference those remotes as they do not hold a guarantee that the history is preserved.

Each interaction chain reference should contain an object named `metadata.json` that fully describes that specific interaction's data.

Otherwise, interaction chains should be namespaced with the type then resource separated by a slash. For example, an `nfgt` with a resource ID of `abcd` should be on a branch named `nfgt/abcd`.

### Committing a Transaction

A transaction is considered committed if the commit is tagged with the transaction ID. This means that a transaction can be written but not considered committed if the commit is in the git repo, but the commit hasn't been tagged yet or pushed to the repository. A transaction isn't considered finalized until a client synchronizes against the upstream.

### Immutability

Immutability will be enforced by requiring linear history on GitHub, and disabling force pushes. This does not prevent leaked deploy keys from wreaking havoc on the chain state, so it's important to keep deploy keys safe.

## Proof-of-Identity

Proof-of-identity is facilitated by deploy keys offered by GitHub. As described in the high-level overview, read-write deploy keys allow nodes to act as validators, while read-only deploy keys allow nodes to be observers.

### HTTP API

The API has the following routes:

- `POST /api/transaction/create` - create a transaction. Takes a `json` with an `owner_id`, `asset_id`, `passphrase`, and `metadata`
- `GET  /api/transaction/status/:transactionId` - checks the status of a transaction. This should be performed after the creation to poll the status

- `GET /api/query/spot/owner/:ownerId` - the owner's current assets
- `GET /api/query/spot/asset/:assetId` - the asset's current metadata (ie. its latest transaction)

- `GET /api/query/history/owner/:ownerId/:depth` - the owner's transaction history up to `:depth`
- `GET /api/query/history/asset/:assetId/:depth` - the asset's transaction history up to `:depth`

Response codes are standardized -- 400 means you did something wrong, 500 means the server had an issue and that you should try again.

# Integrations

## Integration with AiBot

AiBot's host will likely run a validator that will process the majority of transactions. It will provide an interface that allows users to mint NFGTs, as well as the ability to automatically manager successor passphrases to facilitate trading. Note that the concept of GuyaCoin is unknown to the NFGT technical universe, so AiBot should manage these transactions in a layer-2 fashion to the base git layer.

Transactions between AiBot and users (such as for Guyacha) can be facilitated by transacting between the bot's user ID and a user's user ID. When a user rolls for an NFT, AiBot should check its inventory with the node and trigger a transaction if AiBot owns the NFT. Otherwise, a soft error path should be provided to reroll a given result.

## Integration with Guya.moe

There are two approaches to integrating Guya.moe.

### Reading the Chain Directly

The chains will have a stable URL through the format of `https://raw.githubusercontent.com/${user}/${repo}/${branch}/metadata.json`, which returns CORS headers. The reader should test for metadata on each reference to display relevant data when necessary.
